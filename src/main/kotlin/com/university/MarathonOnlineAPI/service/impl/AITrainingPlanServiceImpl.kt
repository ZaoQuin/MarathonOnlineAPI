package com.university.MarathonOnlineAPI.service.impl

import com.university.MarathonOnlineAPI.entity.*
import com.university.MarathonOnlineAPI.repos.*
import com.university.MarathonOnlineAPI.service.AITrainingPlanService
import io.github.cdimascio.dotenv.Dotenv
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import org.json.JSONArray
import org.json.JSONObject
import org.springframework.stereotype.Service
import java.io.IOException
import java.util.regex.Pattern

@Service
class AITrainingPlanServiceImpl(
    private val trainingSessionRepository: TrainingSessionRepository,
    private val trainingDayRepository: TrainingDayRepository,
    private val userRepository: UserRepository
): AITrainingPlanService {
    val dotenv = Dotenv.load()!!
    val apiKey = dotenv["GROQ_API_KEY"]!!
    private val GROQ_MODEL = "llama3-70b-8192"

    override fun generateTrainingDays(input: TrainingPlanInput, plan: TrainingPlan): List<TrainingDay> {
        // T·∫°o prompt cho AI d·ª±a tr√™n th√¥ng tin ƒë·∫ßu v√†o
        val prompt = createPromptForAI(input)

        // G·ªçi API AI ƒë·ªÉ t·∫°o l·ªãch tr√¨nh
        val aiResponse = callAIApi(prompt)

        // X·ª≠ l√Ω ph·∫£n h·ªìi t·ª´ AI
        val trainingDays = parseAIResponse(aiResponse, plan)

        // L∆∞u t·∫•t c·∫£ training days
        return trainingDayRepository.saveAll(trainingDays)
    }

    private fun createPromptForAI(input: TrainingPlanInput): String {
        return """
        H√£y t·∫°o m·ªôt l·ªãch tr√¨nh luy·ªán t·∫≠p marathon chi ti·∫øt d∆∞·ªõi d·∫°ng JSON d·ª±a tr√™n th√¥ng tin c·ªßa runner sau:

        ‚Ä¢ Tr√¨nh ƒë·ªô: ${input.level}
        ‚Ä¢ M·ª•c ti√™u: ${input.goal}
        ‚Ä¢ Kho·∫£ng c√°ch d√†i nh·∫•t t·ª´ng ch·∫°y: ${input.maxDistance} km
        ‚Ä¢ T·ªëc ƒë·ªô trung b√¨nh: ${input.averagePace} ph√∫t/km
        ‚Ä¢ T·ªïng s·ªë tu·∫ßn luy·ªán t·∫≠p: ${input.weeks}
        ‚Ä¢ S·ªë bu·ªïi t·∫≠p m·ªói tu·∫ßn: ${input.daysPerWeek}

        ‚ú≥Ô∏è **Y√äU C·∫¶U ƒê·∫¶U RA**:
        Tr·∫£ v·ªÅ m·ªôt **m·∫£ng JSON h·ª£p l·ªá**, KH√îNG th√™m vƒÉn b·∫£n gi·∫£i th√≠ch. M·ªói ph·∫ßn t·ª≠ trong m·∫£ng t∆∞∆°ng ·ª©ng v·ªõi m·ªôt ng√†y trong l·ªãch tr√¨nh v·ªõi c√°c tr∆∞·ªùng l√† b·∫Øt bu·ªôc, c√≥ ƒë·ªãnh d·∫°ng:

        {
          "week": [s·ªë tu·∫ßn, t·ª´ 1 ƒë·∫øn ${input.weeks}],
          "dayOfWeek": [ng√†y trong tu·∫ßn, t·ª´ 1 (Th·ª© Hai) ƒë·∫øn 7 (Ch·ªß Nh·∫≠t)],
          "session": {
            "name": "[t√™n bu·ªïi t·∫≠p]",
            "type": "[LONG_RUN | RECOVERY_RUN | SPEED_WORK | REST]",
            "distance": [s·ªë km, s·ªë th·∫≠p ph√¢n, d√πng 0 n·∫øu REST],
            "pace": [ph√∫t/km, s·ªë th·∫≠p ph√¢n, d√πng 0 n·∫øu REST],
            "notes": "Nh·∫Øc nh·ªü ng·∫Øn t√πy thu·ªôc lo·∫°i h√¨nh t·∫≠p luy·ªán, v√≠ d·ª•: 'Gi·ªØ pace ·ªïn ƒë·ªãnh to√†n bu·ªïi', "
          }
        }

        üìå **Quan tr·ªçng**:
        ‚Ä¢ M·ªói **tu·∫ßn ph·∫£i c√≥ ƒë√∫ng 7 ng√†y** (t∆∞∆°ng ·ª©ng 7 ph·∫ßn t·ª≠ c√≥ dayOfWeek t·ª´ 1 ƒë·∫øn 7).
        ‚Ä¢ N·∫øu ch·ªâ t·∫≠p luy·ªán ${input.daysPerWeek} ng√†y/tu·∫ßn, th√¨ c√°c ng√†y c√≤n l·∫°i ph·∫£i ƒë∆∞·ª£c ƒë√°nh d·∫•u l√† `"REST"`.

        üß† **Nguy√™n t·∫Øc x√¢y d·ª±ng k·∫ø ho·∫°ch**:
        1. LONG_RUN tƒÉng d·∫ßn qua t·ª´ng tu·∫ßn, b·∫Øt ƒë·∫ßu t·ª´ ${(input.maxDistance ?: 10.0).coerceAtLeast(5.0)} km.
        2. SPEED_WORK c·∫ßn ƒëa d·∫°ng (fartlek, interval, tempo, hill repeats).
        3. RECOVERY_RUN n√™n ch·∫≠m h∆°n pace trung b√¨nh 1‚Äì2 ph√∫t/km.
        4. Tr√°nh x·∫øp `"LONG_RUN"` v√† `"SPEED_WORK"` v√†o hai ng√†y li√™n ti·∫øp.

        üìä **S·ªë ph·∫ßn t·ª≠ trong m·∫£ng ƒë·∫ßu ra**:
        ${input.weeks} tu·∫ßn √ó 7 ng√†y = ${input.weeks?.times(7)} ph·∫ßn t·ª≠.

        üëâ Nh·∫Øc l·∫°i: **Ch·ªâ tr·∫£ v·ªÅ m·∫£ng JSON h·ª£p l·ªá, ƒë·∫ßy ƒë·ªß 7 ng√†y m·ªói tu·∫ßn. Kh√¥ng th√™m vƒÉn b·∫£n m√¥ t·∫£ n√†o kh√°c**.

    """.trimIndent()
    }



    private fun callAIApi(prompt: String): String {
        val client = OkHttpClient()

        val messageObj = JSONObject()
            .put("role", "user")
            .put("content", prompt)

        val jsonBody = JSONObject()
            .put("model", GROQ_MODEL)
            .put("messages", JSONArray().put(messageObj))
            .put("temperature", 0.7)

        val request = Request.Builder()
            .url("https://api.groq.com/openai/v1/chat/completions")
            .addHeader("Content-Type", "application/json")
            .addHeader("Authorization", "Bearer $apiKey")
            .post(jsonBody.toString().toRequestBody("application/json".toMediaType()))
            .build()

        client.newCall(request).execute().use { response ->
            if (!response.isSuccessful) throw IOException("Unexpected code $response")

            val responseBody = response.body?.string() ?: ""
            println("AI raw response: $responseBody")

            val jsonResponse = JSONObject(responseBody)
            return jsonResponse.getJSONArray("choices")
                .getJSONObject(0)
                .getJSONObject("message")
                .getString("content")
        }
    }


    private fun parseAIResponse(aiResponse: String, plan: TrainingPlan): List<TrainingDay> {
        val trainingDays = mutableListOf<TrainingDay>()

        try {
            // T√¨m v√† tr√≠ch xu·∫•t ph·∫ßn JSON t·ª´ ph·∫£n h·ªìi
            val jsonPattern = Pattern.compile("\\[\\s*\\{.*\\}\\s*\\]", Pattern.DOTALL)
            val matcher = jsonPattern.matcher(aiResponse)

            if (matcher.find()) {
                val jsonArray = JSONArray(matcher.group())

                for (i in 0 until jsonArray.length()) {
                    val dayJson = jsonArray.getJSONObject(i)
                    val sessionJson = dayJson.getJSONObject("session")

                    // T·∫°o ho·∫∑c t√¨m session
                    val session = TrainingSession(
                        name = sessionJson.getString("name"),
                        type = ETrainingSessionType.valueOf(sessionJson.getString("type")),
                        distance = sessionJson.getDouble("distance"),
                        pace = sessionJson.getDouble("pace"),
                        notes = if (sessionJson.has("notes")) sessionJson.getString("notes") else null
                    )

                    val savedSession = trainingSessionRepository.save(session)

                    // T·∫°o training day
                    val trainingDay = TrainingDay().apply {
                        this.plan = plan
                        this.session = savedSession
                        this.week = dayJson.getInt("week")
                        this.dayOfWeek = dayJson.getInt("dayOfWeek")
                    }

                    trainingDays.add(trainingDay)
                }
            } else {
                // N·∫øu kh√¥ng t√¨m th·∫•y JSON, t·∫°o l·ªãch tr√¨nh m·∫∑c ƒë·ªãnh
                trainingDays.addAll(createDefaultTrainingPlan(plan))
            }
        } catch (e: Exception) {
            // Log l·ªói v√† t·∫°o l·ªãch tr√¨nh m·∫∑c ƒë·ªãnh
            println("Error parsing AI response: ${e.message}")
            e.printStackTrace()
            trainingDays.addAll(createDefaultTrainingPlan(plan))
        }

        return trainingDays
    }

    private fun createDefaultTrainingPlan(plan: TrainingPlan): List<TrainingDay> {
        val trainingDays = mutableListOf<TrainingDay>()
        val weeks = plan.input.weeks ?: 12
        val daysPerWeek = plan.input.daysPerWeek ?: 4

        for (week in 1..weeks) {
            // D·ª±a tr√™n s·ªë ng√†y t·∫≠p luy·ªán m·ªói tu·∫ßn, ph√¢n b·ªï c√°c ng√†y t·∫≠p luy·ªán
            val restDays = 7 - daysPerWeek
            val trainingDaysInWeek = (1..7).filter { it > restDays }.toList()

            for (day in trainingDaysInWeek) {
                // X√°c ƒë·ªãnh lo·∫°i bu·ªïi t·∫≠p d·ª±a tr√™n ng√†y trong tu·∫ßn
                val sessionType = when {
                    day == 7 -> ETrainingSessionType.LONG_RUN    // Ch·ªß nh·∫≠t = ch·∫°y d√†i
                    day % 2 == 0 -> ETrainingSessionType.SPEED_WORK // Ng√†y ch·∫µn = t·∫≠p t·ªëc ƒë·ªô
                    else -> ETrainingSessionType.RECOVERY_RUN    // Ng√†y l·∫ª = ch·∫°y h·ªìi ph·ª•c
                }

                // T√≠nh kho·∫£ng c√°ch d·ª±a tr√™n tu·∫ßn v√† lo·∫°i bu·ªïi t·∫≠p
                val baseDistance = when (sessionType) {
                    ETrainingSessionType.LONG_RUN -> 5.0 + (week * 2.5) // TƒÉng d·∫ßn l√™n 35km
                    ETrainingSessionType.SPEED_WORK -> 5.0
                    ETrainingSessionType.RECOVERY_RUN -> 3.0 + (week * 0.5).coerceAtMost(7.0)
                    else -> 0.0
                }

                // ƒêi·ªÅu ch·ªânh kho·∫£ng c√°ch cho tu·∫ßn cu·ªëi (marathon)
                val distance = if (week == weeks && sessionType == ETrainingSessionType.LONG_RUN) {
                    42.195 // Marathon ƒë·∫ßy ƒë·ªß
                } else {
                    baseDistance
                }

                // T√≠nh pace d·ª±a tr√™n lo·∫°i bu·ªïi t·∫≠p
                val basePace = plan.input.averagePace ?: 6.0
                val pace = when (sessionType) {
                    ETrainingSessionType.LONG_RUN -> basePace + 1.0 // Ch·∫°y d√†i th√¨ ch·∫≠m h∆°n
                    ETrainingSessionType.SPEED_WORK -> (basePace - 1.0).coerceAtLeast(4.0) // Nhanh h∆°n
                    ETrainingSessionType.RECOVERY_RUN -> basePace + 1.5 // Ch·∫≠m h∆°n nhi·ªÅu
                    else -> 0.0
                }

                // T·∫°o session
                val session = TrainingSession(
                    name = when (sessionType) {
                        ETrainingSessionType.LONG_RUN -> "Ch·∫°y d√†i tu·∫ßn $week"
                        ETrainingSessionType.SPEED_WORK -> "T·∫≠p t·ªëc ƒë·ªô tu·∫ßn $week"
                        ETrainingSessionType.RECOVERY_RUN -> "Ch·∫°y h·ªìi ph·ª•c tu·∫ßn $week"
                        else -> "Ngh·ªâ"
                    },
                    type = sessionType,
                    distance = distance,
                    pace = pace,
                    notes = "Bu·ªïi t·∫≠p t·ª± ƒë·ªông t·∫°o cho tu·∫ßn $week",
                )

                val savedSession = trainingSessionRepository.save(session)

                // T·∫°o training day
                val trainingDay = TrainingDay().apply {
                    this.plan = plan
                    this.session = savedSession
                    this.week = week
                    this.dayOfWeek = day
                }

                trainingDays.add(trainingDay)
            }
        }

        return trainingDays
    }
}